import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { updateCSS } from "rc-util/es/Dom/dynamicCSS";
import { composeRef, supportRef } from "rc-util/es/ref";
import * as React from 'react';
import { forwardRef } from 'react';
import { ConfigConsumer, ConfigContext } from '../../config-provider';
import raf from '../raf';
import { cloneElement } from '../reactNode';
import useStyle from './style';
let styleForPseudo;
// Where el is the DOM element you'd like to test for visibility
function isHidden(element) {
  if (process.env.NODE_ENV === 'test') {
    return false;
  }
  return !element || element.offsetParent === null || element.hidden;
}
function getValidateContainer(nodeRoot) {
  if (nodeRoot instanceof Document) {
    return nodeRoot.body;
  }
  return Array.from(nodeRoot.childNodes).find(ele => (ele === null || ele === void 0 ? void 0 : ele.nodeType) === Node.ELEMENT_NODE);
}
function isNotGrey(color) {
  // eslint-disable-next-line no-useless-escape
  const match = (color || '').match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match && match[1] && match[2] && match[3]) {
    return !(match[1] === match[2] && match[2] === match[3]);
  }
  return true;
}
function isValidWaveColor(color) {
  return color && color !== '#fff' && color !== '#ffffff' && color !== 'rgb(255, 255, 255)' && color !== 'rgba(255, 255, 255, 1)' && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) &&
  // any transparent rgba color
  color !== 'transparent';
}
function getTargetWaveColor(node) {
  const computedStyle = getComputedStyle(node);
  const borderTopColor = computedStyle.getPropertyValue('border-top-color');
  const borderColor = computedStyle.getPropertyValue('border-color');
  const backgroundColor = computedStyle.getPropertyValue('background-color');
  if (isValidWaveColor(borderTopColor)) {
    return borderTopColor;
  }
  if (isValidWaveColor(borderColor)) {
    return borderColor;
  }
  return backgroundColor;
}
export let InternalWave = /*#__PURE__*/function (_React$Component) {
  _inherits(InternalWave, _React$Component);
  var _super = _createSuper(InternalWave);
  function InternalWave() {
    var _this;
    _classCallCheck(this, InternalWave);
    _this = _super.apply(this, arguments);
    _this.containerRef = /*#__PURE__*/React.createRef();
    _this.animationStart = false;
    _this.destroyed = false;
    _this.onClick = (node, waveColor) => {
      var _a, _b;
      const {
        insertExtraNode,
        disabled
      } = _this.props;
      if (disabled || !node || isHidden(node) || node.className.includes('-leave')) {
        return;
      }
      _this.extraNode = document.createElement('div');
      const {
        extraNode
      } = _assertThisInitialized(_this);
      const {
        getPrefixCls
      } = _this.context;
      extraNode.className = `${getPrefixCls('')}-click-animating-node`;
      const attributeName = _this.getAttributeName();
      node.setAttribute(attributeName, 'true');
      // Not white or transparent or grey
      if (isValidWaveColor(waveColor)) {
        extraNode.style.borderColor = waveColor;
        const nodeRoot = ((_a = node.getRootNode) === null || _a === void 0 ? void 0 : _a.call(node)) || node.ownerDocument;
        const nodeBody = (_b = getValidateContainer(nodeRoot)) !== null && _b !== void 0 ? _b : nodeRoot;
        styleForPseudo = updateCSS(`
      [${getPrefixCls('')}-click-animating-without-extra-node='true']::after, .${getPrefixCls('')}-click-animating-node {
        --antd-wave-shadow-color: ${waveColor};
      }`, 'antd-wave', {
          csp: _this.csp,
          attachTo: nodeBody
        });
      }
      if (insertExtraNode) {
        node.appendChild(extraNode);
      }
      ['transition', 'animation'].forEach(name => {
        node.addEventListener(`${name}start`, _this.onTransitionStart);
        node.addEventListener(`${name}end`, _this.onTransitionEnd);
      });
    };
    _this.onTransitionStart = e => {
      if (_this.destroyed) {
        return;
      }
      const node = _this.containerRef.current;
      if (!e || e.target !== node || _this.animationStart) {
        return;
      }
      _this.resetEffect(node);
    };
    _this.onTransitionEnd = e => {
      if (!e || e.animationName !== 'fadeEffect') {
        return;
      }
      _this.resetEffect(e.target);
    };
    _this.bindAnimationEvent = node => {
      if (!node || !node.getAttribute || node.getAttribute('disabled') || node.className.includes('disabled')) {
        return;
      }
      const onClick = e => {
        // Fix radio button click twice
        if (e.target.tagName === 'INPUT' || isHidden(e.target)) {
          return;
        }
        _this.resetEffect(node);
        // Get wave color from target
        const waveColor = getTargetWaveColor(node);
        _this.clickWaveTimeoutId = window.setTimeout(() => _this.onClick(node, waveColor), 0);
        raf.cancel(_this.animationStartId);
        _this.animationStart = true;
        // Render to trigger transition event cost 3 frames. Let's delay 10 frames to reset this.
        _this.animationStartId = raf(() => {
          _this.animationStart = false;
        }, 10);
      };
      node.addEventListener('click', onClick, true);
      return {
        cancel: () => {
          node.removeEventListener('click', onClick, true);
        }
      };
    };
    _this.renderWave = _ref => {
      let {
        csp
      } = _ref;
      const {
        children
      } = _this.props;
      _this.csp = csp;
      if (! /*#__PURE__*/React.isValidElement(children)) return children;
      let ref = _this.containerRef;
      if (supportRef(children)) {
        ref = composeRef(children.ref, _this.containerRef);
      }
      return cloneElement(children, {
        ref
      });
    };
    return _this;
  }
  _createClass(InternalWave, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      const node = this.containerRef.current;
      if (!node || node.nodeType !== 1) {
        return;
      }
      this.instance = this.bindAnimationEvent(node);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.instance) {
        this.instance.cancel();
      }
      if (this.clickWaveTimeoutId) {
        clearTimeout(this.clickWaveTimeoutId);
      }
      this.destroyed = true;
    }
  }, {
    key: "getAttributeName",
    value: function getAttributeName() {
      const {
        getPrefixCls
      } = this.context;
      const {
        insertExtraNode
      } = this.props;
      return insertExtraNode ? `${getPrefixCls('')}-click-animating` : `${getPrefixCls('')}-click-animating-without-extra-node`;
    }
  }, {
    key: "resetEffect",
    value: function resetEffect(node) {
      if (!node || node === this.extraNode || !(node instanceof Element)) {
        return;
      }
      const {
        insertExtraNode
      } = this.props;
      const attributeName = this.getAttributeName();
      node.setAttribute(attributeName, 'false'); // edge has bug on `removeAttribute` #14466
      if (styleForPseudo) {
        styleForPseudo.innerHTML = '';
      }
      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {
        node.removeChild(this.extraNode);
      }
      ['transition', 'animation'].forEach(name => {
        node.removeEventListener(`${name}start`, this.onTransitionStart);
        node.removeEventListener(`${name}end`, this.onTransitionEnd);
      });
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement(ConfigConsumer, null, this.renderWave);
    }
  }]);
  return InternalWave;
}(React.Component);
InternalWave.contextType = ConfigContext;
const Wave = /*#__PURE__*/forwardRef((props, ref) => {
  useStyle();
  return /*#__PURE__*/React.createElement(InternalWave, Object.assign({
    ref: ref
  }, props));
});
export default Wave;